// Package Swagger provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package restapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetArticles request
	GetArticles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateArticle request  with any body
	CreateArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateArticle(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete request
	Delete(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArticleBySlug request
	GetArticleBySlug(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateArticle request  with any body
	UpdateArticleWithBody(ctx context.Context, slug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateArticle(ctx context.Context, slug string, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAuthor request  with any body
	CreateAuthorWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAuthor(ctx context.Context, body CreateAuthorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorByName request
	GetAuthorByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJuliaNOTTOP request
	GetJuliaNOTTOP(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTags request
	GetTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetArticles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArticlesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateArticleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateArticle(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateArticleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRequest(c.Server, slug)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArticleBySlug(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArticleBySlugRequest(c.Server, slug)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateArticleWithBody(ctx context.Context, slug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateArticleRequestWithBody(c.Server, slug, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateArticle(ctx context.Context, slug string, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateArticleRequest(c.Server, slug, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthorWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthorRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthor(ctx context.Context, body CreateAuthorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthorRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJuliaNOTTOP(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJuliaNOTTOPRequest(c.Server)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetArticlesRequest generates requests for GetArticles
func NewGetArticlesRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/articles")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateArticleRequest calls the generic CreateArticle builder with application/json body
func NewCreateArticleRequest(server string, body CreateArticleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateArticleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateArticleRequestWithBody generates requests for CreateArticle with any type of body
func NewCreateArticleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/articles")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRequest generates requests for Delete
func NewDeleteRequest(server string, slug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "slug", slug)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/articles/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArticleBySlugRequest generates requests for GetArticleBySlug
func NewGetArticleBySlugRequest(server string, slug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "slug", slug)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/articles/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateArticleRequest calls the generic UpdateArticle builder with application/json body
func NewUpdateArticleRequest(server string, slug string, body UpdateArticleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateArticleRequestWithBody(server, slug, "application/json", bodyReader)
}

// NewUpdateArticleRequestWithBody generates requests for UpdateArticle with any type of body
func NewUpdateArticleRequestWithBody(server string, slug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "slug", slug)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/articles/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAuthorRequest calls the generic CreateAuthor builder with application/json body
func NewCreateAuthorRequest(server string, body CreateAuthorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAuthorRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAuthorRequestWithBody generates requests for CreateAuthor with any type of body
func NewCreateAuthorRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/authors")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAuthorByNameRequest generates requests for GetAuthorByName
func NewGetAuthorByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "name", name)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/authors/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJuliaNOTTOPRequest generates requests for GetJuliaNOTTOP
func NewGetJuliaNOTTOPRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/julia")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagsRequest generates requests for GetTags
func NewGetTagsRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/tags")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	req = req.WithContext(ctx)
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetArticles request
	GetArticlesWithResponse(ctx context.Context) (*GetArticlesResponse, error)

	// CreateArticle request  with any body
	CreateArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateArticleResponse, error)

	CreateArticleWithResponse(ctx context.Context, body CreateArticleJSONRequestBody) (*CreateArticleResponse, error)

	// Delete request
	DeleteWithResponse(ctx context.Context, slug string) (*DeleteResponse, error)

	// GetArticleBySlug request
	GetArticleBySlugWithResponse(ctx context.Context, slug string) (*GetArticleBySlugResponse, error)

	// UpdateArticle request  with any body
	UpdateArticleWithBodyWithResponse(ctx context.Context, slug string, contentType string, body io.Reader) (*UpdateArticleResponse, error)

	UpdateArticleWithResponse(ctx context.Context, slug string, body UpdateArticleJSONRequestBody) (*UpdateArticleResponse, error)

	// CreateAuthor request  with any body
	CreateAuthorWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateAuthorResponse, error)

	CreateAuthorWithResponse(ctx context.Context, body CreateAuthorJSONRequestBody) (*CreateAuthorResponse, error)

	// GetAuthorByName request
	GetAuthorByNameWithResponse(ctx context.Context, name string) (*GetAuthorByNameResponse, error)

	// GetJuliaNOTTOP request
	GetJuliaNOTTOPWithResponse(ctx context.Context) (*GetJuliaNOTTOPResponse, error)

	// GetTags request
	GetTagsWithResponse(ctx context.Context) (*GetTagsResponse, error)
}

type GetArticlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ArticleRequest `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetArticlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArticlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateArticleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ArticleResponse `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateArticleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateArticleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArticleBySlugResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticleResponse
}

// Status returns HTTPResponse.Status
func (r GetArticleBySlugResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArticleBySlugResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateArticleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ArticleResponse
}

// Status returns HTTPResponse.Status
func (r UpdateArticleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateArticleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAuthorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]AuthorResponse `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAuthorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAuthorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthorResponse
}

// Status returns HTTPResponse.Status
func (r GetAuthorByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJuliaNOTTOPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetJuliaNOTTOPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJuliaNOTTOPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]string `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetArticlesWithResponse request returning *GetArticlesResponse
func (c *ClientWithResponses) GetArticlesWithResponse(ctx context.Context) (*GetArticlesResponse, error) {
	rsp, err := c.GetArticles(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetArticlesResponse(rsp)
}

// CreateArticleWithBodyWithResponse request with arbitrary body returning *CreateArticleResponse
func (c *ClientWithResponses) CreateArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateArticleResponse, error) {
	rsp, err := c.CreateArticleWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateArticleResponse(rsp)
}

func (c *ClientWithResponses) CreateArticleWithResponse(ctx context.Context, body CreateArticleJSONRequestBody) (*CreateArticleResponse, error) {
	rsp, err := c.CreateArticle(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateArticleResponse(rsp)
}

// DeleteWithResponse request returning *DeleteResponse
func (c *ClientWithResponses) DeleteWithResponse(ctx context.Context, slug string) (*DeleteResponse, error) {
	rsp, err := c.Delete(ctx, slug)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResponse(rsp)
}

// GetArticleBySlugWithResponse request returning *GetArticleBySlugResponse
func (c *ClientWithResponses) GetArticleBySlugWithResponse(ctx context.Context, slug string) (*GetArticleBySlugResponse, error) {
	rsp, err := c.GetArticleBySlug(ctx, slug)
	if err != nil {
		return nil, err
	}
	return ParseGetArticleBySlugResponse(rsp)
}

// UpdateArticleWithBodyWithResponse request with arbitrary body returning *UpdateArticleResponse
func (c *ClientWithResponses) UpdateArticleWithBodyWithResponse(ctx context.Context, slug string, contentType string, body io.Reader) (*UpdateArticleResponse, error) {
	rsp, err := c.UpdateArticleWithBody(ctx, slug, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateArticleResponse(rsp)
}

func (c *ClientWithResponses) UpdateArticleWithResponse(ctx context.Context, slug string, body UpdateArticleJSONRequestBody) (*UpdateArticleResponse, error) {
	rsp, err := c.UpdateArticle(ctx, slug, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateArticleResponse(rsp)
}

// CreateAuthorWithBodyWithResponse request with arbitrary body returning *CreateAuthorResponse
func (c *ClientWithResponses) CreateAuthorWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateAuthorResponse, error) {
	rsp, err := c.CreateAuthorWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthorResponse(rsp)
}

func (c *ClientWithResponses) CreateAuthorWithResponse(ctx context.Context, body CreateAuthorJSONRequestBody) (*CreateAuthorResponse, error) {
	rsp, err := c.CreateAuthor(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthorResponse(rsp)
}

// GetAuthorByNameWithResponse request returning *GetAuthorByNameResponse
func (c *ClientWithResponses) GetAuthorByNameWithResponse(ctx context.Context, name string) (*GetAuthorByNameResponse, error) {
	rsp, err := c.GetAuthorByName(ctx, name)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorByNameResponse(rsp)
}

// GetJuliaNOTTOPWithResponse request returning *GetJuliaNOTTOPResponse
func (c *ClientWithResponses) GetJuliaNOTTOPWithResponse(ctx context.Context) (*GetJuliaNOTTOPResponse, error) {
	rsp, err := c.GetJuliaNOTTOP(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetJuliaNOTTOPResponse(rsp)
}

// GetTagsWithResponse request returning *GetTagsResponse
func (c *ClientWithResponses) GetTagsWithResponse(ctx context.Context) (*GetTagsResponse, error) {
	rsp, err := c.GetTags(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsResponse(rsp)
}

// ParseGetArticlesResponse parses an HTTP response from a GetArticlesWithResponse call
func ParseGetArticlesResponse(rsp *http.Response) (*GetArticlesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetArticlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ArticleRequest `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateArticleResponse parses an HTTP response from a CreateArticleWithResponse call
func ParseCreateArticleResponse(rsp *http.Response) (*CreateArticleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateArticleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ArticleResponse `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteResponse parses an HTTP response from a DeleteWithResponse call
func ParseDeleteResponse(rsp *http.Response) (*DeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetArticleBySlugResponse parses an HTTP response from a GetArticleBySlugWithResponse call
func ParseGetArticleBySlugResponse(rsp *http.Response) (*GetArticleBySlugResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetArticleBySlugResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateArticleResponse parses an HTTP response from a UpdateArticleWithResponse call
func ParseUpdateArticleResponse(rsp *http.Response) (*UpdateArticleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateArticleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ArticleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseCreateAuthorResponse parses an HTTP response from a CreateAuthorWithResponse call
func ParseCreateAuthorResponse(rsp *http.Response) (*CreateAuthorResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateAuthorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]AuthorResponse `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAuthorByNameResponse parses an HTTP response from a GetAuthorByNameWithResponse call
func ParseGetAuthorByNameResponse(rsp *http.Response) (*GetAuthorByNameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJuliaNOTTOPResponse parses an HTTP response from a GetJuliaNOTTOPWithResponse call
func ParseGetJuliaNOTTOPResponse(rsp *http.Response) (*GetJuliaNOTTOPResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetJuliaNOTTOPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTagsResponse parses an HTTP response from a GetTagsWithResponse call
func ParseGetTagsResponse(rsp *http.Response) (*GetTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
